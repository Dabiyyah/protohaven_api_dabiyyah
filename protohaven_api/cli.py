""" A set of command line tools, possibly run by CRON"""

import argparse
import datetime
import json
import logging
import os
import re
import sys
from collections import defaultdict

import yaml
from dateutil import parser as dateparser

from protohaven_api.class_automation import scheduler
from protohaven_api.commands import classes, reservations
from protohaven_api.config import get_config, tz, tznow
from protohaven_api.integrations import airtable, comms, neon, sheets, tasks
from protohaven_api.integrations.airtable import log_email
from protohaven_api.integrations.comms import send_discord_message, send_email
from protohaven_api.integrations.data.connector import init as init_connector
from protohaven_api.maintenance import manager
from protohaven_api.policy_enforcement import enforcer
from protohaven_api.validation.docs import validate as validate_docs

LOGLEVEL = os.environ.get("LOGLEVEL", "INFO").upper()
logging.basicConfig(level=LOGLEVEL)
log = logging.getLogger("cli")
server_mode = os.getenv("PH_SERVER_MODE", "dev").lower()
log.info(f"Mode is {server_mode}\n")
init_connector(dev=server_mode != "prod")


completion_re = re.compile("Deadline for Project Completion:\n(.*?)\n", re.MULTILINE)
description_re = re.compile("Project Description:\n(.*?)Materials Budget", re.MULTILINE)


def purchase_request_alerts():
    """Send alerts when there's purchase requests that haven't been acted upon for some time"""
    content = "**Open Purchase Requests Report:**"
    sections = defaultdict(list)
    counts = defaultdict(int)
    now = tznow()
    thresholds = {
        "low_pri": 7,
        "high_pri": 2,
        "class_supply": 3,
        "on_hold": 30,
        "unknown": 0,
    }
    headers = {
        "low_pri": "Low Priority",
        "high_pri": "High Priority",
        "class_supply": "Class Supplies",
        "on_hold": "On Hold",
        "unknown": "Unknown/Unparsed Tasks",
    }

    def format_request(t):
        if (t["modified_at"] - t["created_at"]).days > 1:
            dt = (now - t["modified_at"]).days
            dstr = f"modified {dt}d ago"
        else:
            dt = (now - t["created_at"]).days
            dstr = f"created {dt}d ago"
        return (f"- {t['name']} ({dstr})", dt)

    for t in tasks.get_open_purchase_requests():
        counts[t["category"]] += 1
        thresh = now - datetime.timedelta(days=thresholds[t["category"]])
        if t["created_at"] < thresh and t["modified_at"] < thresh:
            sections[t["category"]].append(format_request(t))

    # Sort oldest to youngest, by section
    for k, v in sections.items():
        v.sort(key=lambda t: -t[1])
        sections[k] = [t[0] for t in v]

    section_added = False
    for k in ("high_pri", "class_supply", "low_pri", "on_hold", "unknown"):
        if len(sections[k]) > 0:
            section_added = True
            content += f"\n\n{headers[k]} ({counts[k]} total open; "
            content += f"showing only tasks older than {thresholds[k]} days):\n"
            content += "\n".join(sections[k])

    if not section_added:
        content += "\nAll caught up. Nice."

    log.info(content)
    comms.send_board_message(content)
    log.info("Done")


class ProtohavenCLI(reservations.Commands, classes.Commands):
    """argparser-based CLI for protohaven operations"""

    def __init__(self):
        helptext = "\n".join(
            [
                f"{a}: {getattr(self, a).__doc__}"
                for a in dir(self)
                if not a.startswith("__")
            ]
        )
        parser = argparse.ArgumentParser(
            description="Protohaven CLI",
            usage=f"{sys.argv[0]} <command> [<args>]\n\n{helptext}\n\n\n",
        )
        parser.add_argument("command", help="Subcommand to run")
        args = parser.parse_args(sys.argv[1:2])  # Limit to only initial command args
        if not hasattr(self, args.command):
            parser.print_help()
            sys.exit(1)
        getattr(self, args.command)(
            sys.argv[2:]
        )  # Ignore first two argvs - already parsed

    def send_comms(self, argv):
        """Reads a list of emails and sends them to their recipients"""
        parser = argparse.ArgumentParser(description=self.send_comms.__doc__)
        parser.add_argument(
            "--path",
            help="path to comms YAML file (typically generated by another command)",
            type=str,
        )
        parser.add_argument(
            "--side-effects",
            help="also carry out side effects e.g. cancelling classes",
            action=argparse.BooleanOptionalAction,
            default=False,
        )
        parser.add_argument(
            "--confirm",
            help="skip interactive confirmation; use for true automation",
            action=argparse.BooleanOptionalAction,
            default=False,
        )
        parser.add_argument(
            "--dryrun",
            help="just print them, don't send them",
            action=argparse.BooleanOptionalAction,
            default=False,
        )
        args = parser.parse_args(argv)

        with open(args.path, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f.read())
        log.info(f"Loaded {len(data)} notifications:")
        for e in data:
            log.info(f" - {e['target']}: {e['subject']}")

        side_effects = defaultdict(list)
        for e in data:
            for sa, sv in e.get("side_effect", {}).items():
                print(sa, sv)
                side_effects[sa] += [sv]

        confstr = f"send {len(data)} notifications"

        if args.side_effects and len(side_effects) > 0:
            log.info(
                f"Also carrying out the following side effects: {dict(side_effects)}"
            )
            confstr += " with side effects"

        if not args.dryrun and not args.confirm:
            confirm = input(f'Please type "{confstr}" to continue: ')
            if confirm != confstr:
                log.error("Confirmation string does not match; exiting")
                sys.exit(1)

        for e in data:
            self._handle_comms_event(e, args.dryrun)
        log.info("Done")

    def validate_docs(self, argv):  # pylint: disable=too-many-statements
        """Go through list of tools in airtable, ensure all of them have
        links to a tool guide and a clearance doc that resolve successfully"""
        parser = argparse.ArgumentParser(description=self.validate_docs.__doc__)
        parser.parse_args(argv)
        result = validate_docs()
        print(yaml.dump([result], default_flow_style=False, default_style=""))

    def project_requests(self, argv):
        """Send alerts when new project requests fall into Asana"""
        parser = argparse.ArgumentParser(description=self.validate_docs.__doc__)
        parser.add_argument(
            "--notify",
            help="when true, send requests to Discord and complete their task in Asana",
            action=argparse.BooleanOptionalAction,
            default=False,
        )
        args = parser.parse_args(argv)
        if not args.notify:
            log.info(
                "\n***   --notify is not set, so projects will not be "
                + "checked off or posted to Discord   ***\n"
            )
        num = 0
        for req in tasks.get_project_requests():
            if req["completed"]:
                continue
            req["notes"] = req["notes"].replace("\\n", "\n")
            deadline = completion_re.search(req["notes"])
            if deadline is None:
                raise RuntimeError(
                    "Failed to extract deadline from request by " + req["name"]
                )
            deadline = dateparser.parse(deadline[1]).astimezone(tz)
            if deadline < tznow():
                log.info(
                    f"Skipping expired project request by {req['name']} (expired {deadline})"
                )
                continue

            content = "**New Project Request:**\n"
            content += req["notes"]
            if args.notify:
                comms.send_help_wanted(content)
                tasks.complete(req["gid"])
                log.info("Sent to discord & marked complete:")
            num += 1
            log.info(content)
        log.info(f"Done - handled {num} project request(s)")

    def new_violation(self, argv):
        """Create a new Violation in Airtable"""
        parser = argparse.ArgumentParser(description=self.new_violation.__doc__)
        parser.add_argument(
            "--reporter",
            help="who's reporting the violation",
            type=str,
            required=True,
        )
        parser.add_argument(
            "--suspect",
            help="who's suspected of causing the violation",
            type=str,
            default=None,
        )
        parser.add_argument(
            "--sections",
            help="comma-separated list of section IDs relevant to violation. See help for list",
            type=str,
            required=True,
        )
        parser.add_argument(
            "--fee", help="fee per day while violation is open", type=float, default=0.0
        )
        parser.add_argument("--notes", help="additional context", type=str, default="")
        args = parser.parse_args(argv)
        result = airtable.open_violation(
            args.reporter,
            args.suspect,
            args.sections.split(","),
            None,
            tznow(),
            args.fee,
            args.notes,
        )
        print(result)

    def close_violation(self, argv):
        """Close out a violation so consequences cease"""
        parser = argparse.ArgumentParser(description=self.new_violation.__doc__)
        parser.add_argument(
            "--id",
            help="instance number for the violation",
            type=int,
            required=True,
        )
        parser.add_argument(
            "--closer",
            help="who's closing the violation",
            type=str,
            required=True,
        )
        parser.add_argument(
            "--suspect",
            help="suspect (if known)",
            type=str,
        )
        parser.add_argument(
            "--notes",
            help="any additionald details",
            type=str,
        )
        args = parser.parse_args(argv)
        result, content = airtable.close_violation(
            args.id, args.closer, tznow(), args.suspect, args.notes
        )
        print(result.status_code, content)

    def enforce_policies(self, argv):  # pylint: disable=too-many-locals
        """Follows suspension & violation logic for any ongoing violations.
        For any violation tagged with a user, generate comms.
        For any action needed to suspend users, generate comms.
        Also generate a summary of changes for sending to Discord."""
        parser = argparse.ArgumentParser(description=self.enforce_policies.__doc__)
        parser.add_argument(
            "--apply",
            help=(
                "Apply fees and suspension actions in Airtable. "
                "If false, they will only be printed"
            ),
            action=argparse.BooleanOptionalAction,
            default=False,
        )
        args = parser.parse_args(argv)

        violations = airtable.get_policy_violations()
        old_fees = [
            (f["fields"]["Violation"][0], f["fields"]["Amount"], f["fields"]["Created"])
            for f in airtable.get_policy_fees()
            if not f["fields"].get("Paid")
        ]
        new_fees = enforcer.gen_fees(violations)
        if len(new_fees) > 0:
            log.info("Generated fees:")
            for f in new_fees:
                log.info(f" - {f[2]} {f[0]} ${f[1]}")
            if args.apply:
                rep = airtable.create_fees(new_fees)
                log.debug(f"{rep.status_code}: {rep.content}")
                log.info(f"Applied {len(new_fees)} fee(s) into Airtable")
            else:
                log.warning("--apply not set; no fee(s) will be added")

        new_sus = enforcer.gen_suspensions()
        if len(new_sus) > 0:
            log.info("Generated suspensions:")
            for s in new_sus:
                log.info(f" - {s}")
            if args.apply:
                for neon_id, duration, violation_ids in new_sus:
                    start = tznow()
                    end = start + datetime.timedelta(duration)
                    rep = airtable.create_suspension(neon_id, violation_ids, start, end)
                    log.debug(f"{rep.status_code}: {rep.content}")
                log.info(f"Applied {len(new_sus)} suspension(s) into Airtable")
            else:
                log.warning("--apply not set; no suspension(s) will be added")

        # Update accrual totals so they're visible at protohaven.org/violations
        enforcer.update_accruals()

        result = enforcer.gen_comms(violations, old_fees, new_fees, new_sus)
        print(yaml.dump(result, default_flow_style=False, default_style=""))
        log.info(f"Generated {len(result)} notification(s)")

    def gen_maintenance_tasks(self, argv):
        """Check recurring tasks list in Airtable, add new tasks to asana
        And notify techs about new and stale tasks that are tech_ready."""
        parser = argparse.ArgumentParser(description=self.gen_maintenance_tasks.__doc__)
        parser.add_argument(
            "--dryrun",
            help="don't actually create new Asana tasks",
            action=argparse.BooleanOptionalAction,
            default=False,
        )
        args = parser.parse_args(argv)
        report = manager.run_daily_maintenance(args.dryrun)
        print(yaml.dump([report], default_flow_style=False, default_style=""))

    def validate_member_clearances(self, argv):
        """Match clearances in spreadsheet with clearances in Neon.
        Remove this when clearance information is primarily stored in Neon."""
        raise NotImplementedError("TODO implement")

    def mock_data(self, argv):
        """Fetch mock data from airtable, neon etc.
        Write this to a file for running without touching production data"""
        parser = argparse.ArgumentParser(description=self.validate_docs.__doc__)
        parser.parse_args(argv)

        sys.stderr.write("Fetching events from neon...\n")
        events = neon.fetch_events()
        # Could also fetch attendees here if needed
        sys.stderr.write("Fetching clearance codes from neon...\n")
        clearance_codes = neon.fetch_clearance_codes()

        sys.stderr.write("Fetching accounts from neon...\n")
        accounts = []
        for acct_id in [1797, 1727, 1438, 1355]:
            accounts.append(neon.fetch_account(acct_id))

        sys.stderr.write("Fetching airtable data...\n")
        cfg = get_config()
        tables = defaultdict(dict)
        for k, v in cfg["airtable"].items():
            for k2 in v.keys():
                if k2 in ("base_id", "token"):
                    continue
                sys.stderr.write(f"{k} {k2}...\n")
                tables[k][k2] = airtable.get_all_records(k, k2)

        sys.stderr.write("Done. Results:\n")
        log.info(
            json.dumps(
                {
                    "neon": {
                        "events": events,
                        "accounts": accounts,
                        "clearance_codes": clearance_codes,
                    },
                    "airtable": tables,
                }
            )
        )


ProtohavenCLI()
